package local_ui

import (
	"fmt"
	"log"
	"os/exec"
	"runtime"
	"strings"
	"time"

	"go.hasen.dev/term"

	"go.hasen.dev/generic"
	"go.hasen.dev/vbeam"
	"go.hasen.dev/vbeam/esbuilder"
)

type InputState struct {
	Click       term.Point
	MouseButton term.MouseButton

	Key rune
}

var FrameInput InputState

type _LocalDev struct {
	Started bool

	LocalServerArgs

	buf  strings.Builder
	logs []string

	scrollPos int // from the bottom

	tsReport vbeam.TSReport
	esReport esbuilder.ESReport

	// for capturing & reporting panics
	Error any

	tsReportState _TSReportState
}

type _TSReportState struct {
	// expanded diagnostics!
	expanded []bool
}

func makeTSReportUI(report vbeam.TSReport) (state _TSReportState) {
	state.expanded = make([]bool, len(report.Diagnostics))
	return
}

// Generated by Claude
func LaunchBrowser(url string) error {
	var cmd *exec.Cmd

	// NOTE: windows and linux handling untested!!

	switch runtime.GOOS {
	case "linux":
		cmd = exec.Command("xdg-open", url)
	case "windows":
		cmd = exec.Command("cmd", "/c", "start", url)
	case "darwin":
		cmd = exec.Command("open", url)
	}

	return cmd.Start()
}

func ClickInRect(rect term.Rect) bool {
	return (FrameInput.MouseButton == term.MousePrimary &&
		term.PointInRect(FrameInput.Click, rect))
}

func RenderText(point *term.Point, style term.Style, text string) term.Rect {
	t := term.TrimStringToWidth(text, term.TermSize.Width-point.X)
	width := t.Width

	var rect term.Rect
	rect.Point = *point
	rect.Height = 1
	rect.Width = width

	term.RenderStyledBlock(rect, term.JustStyledSpan(style, text))
	point.X += width
	return rect
}

func RenderURL(point *term.Point, style term.Style, url string) term.Rect {
	// measure text
	rect := RenderText(point, style, url)

	// if mouse click inside the area written, handle click
	if ClickInRect(rect) {
		launchURL := url
		if !strings.HasPrefix(launchURL, "http://") && !strings.HasPrefix(launchURL, "https://") {
			launchURL = "http://" + launchURL
		}
		LaunchBrowser(launchURL)
	}

	return rect
}

func (m *_LocalDev) accumulateLogLines() {
	lines := strings.Split(m.buf.String(), "\n")
	if len(lines) == 1 {
		return
	}
	last := lines[len(lines)-1]
	lines = lines[:len(lines)-1]
	m.logs = append(m.logs, lines...)
	m.buf.Reset()
	m.buf.WriteString(last)
	log.SetOutput(&m.buf)
}

var startTime = time.Now()

// Generated by Claude
func formatDuration(d time.Duration) string {
	h := d / time.Hour
	d -= h * time.Hour
	m := d / time.Minute
	d -= m * time.Minute
	s := d / time.Second
	return fmt.Sprintf("%02d:%02d:%02d", h, m, s)
}

var redDark = term.RGBto666(100, 10, 20)
var green = term.RGBto666(50, 180, 80)
var greenDark = term.RGBto666(10, 100, 30)
var white = term.RGBto666(250, 250, 250)
var black = term.RGBto666(30, 30, 30)

func (local *_LocalDev) renderFrame() {
	defer func() {
		err := recover()
		if err != nil {
			log.Println("renderFrame ::", err)
			local.Error = err
		}
	}()
	local.accumulateLogLines()

	screenRect := term.Rect{
		Size:  term.TermSize,
		Point: term.HomePos,
	}

	// DrawBox(screen, screenRect, tcell.StyleDefault)
	// PaddRect(&screenRect, 1, 3)
	topRect := screenRect.CutTop(1)
	statusRect := screenRect.CutBottom(1)

	successStyle := term.Style{Background: greenDark, Foreground: white, Attr: term.Bold}
	errorStyle := term.Style{Background: redDark, Foreground: white, Attr: term.Bold}
	titleStyle := term.Style{
		Background: white,
		Foreground: black,
		Attr:       term.Bold,
	}

	yellow := term.Style{Foreground: term.Yellow, Attr: term.DefaultBackground}

	var tsErrorCount = len(local.tsReport.Diagnostics)

	// topbar
	{
		var cursor = topRect.Point
		if local.Started {
			RenderText(&cursor, successStyle, " Started ")
			RenderText(&cursor, successStyle, "    ") // spacing
			var greenUrl = successStyle
			greenUrl.Attr |= term.Underline

			urlPort := fmt.Sprintf("http://localhost:%d", local.Port)
			RenderURL(&cursor, greenUrl, urlPort)

			RenderText(&cursor, successStyle, " | ") // spacing

			urlDomain := fmt.Sprintf("http://%s", local.Domain)
			RenderURL(&cursor, greenUrl, urlDomain)
		} else {
			RenderText(&cursor, yellow, "Starting...")
		}

		tsStatus := topRect.CutRight(30)
		cursor = tsStatus.Point

		// typescript status
		{
			if local.tsReport.Time.IsZero() {
				RenderText(&cursor, yellow, "Type Checking")
			} else {
				checkTime := local.tsReport.Time.Format("15:04")
				if tsErrorCount == 0 {
					RenderText(&cursor, successStyle, checkTime)
					RenderText(&cursor, successStyle, "  ") // spacing
					RenderText(&cursor, successStyle, "Typescript Check OK")
				} else {
					RenderText(&cursor, errorStyle, checkTime)
					RenderText(&cursor, errorStyle, "  ") // spacing
					RenderText(&cursor, errorStyle, fmt.Sprintf("Typescript: %d errors", tsErrorCount))
				}
			}
		}
	}

	screenRect.CutTop(1)    // open up some vertical space
	screenRect.CutBottom(1) // bottom margin

	var tsRect term.Rect

	if tsErrorCount > 0 {
		tsRect = screenRect.CutRight(int(float64(screenRect.Width) * 0.4))
		sep := screenRect.CutRight(1)
		_ = sep
		// TODO: fill sep with something?
	}

	var serverRect = screenRect.CutTop(screenRect.Height)

	// server logs
	{
		titleRect := serverRect.CutTop(1)
		term.RenderStyledBlock(titleRect, term.JustStyledSpan(titleStyle, "  == Server Logs == "))

		// scrolling logic
		var lineSlice = local.logs[:]

		maxOffset := len(lineSlice) - serverRect.Height
		if local.scrollPos > maxOffset {
			local.scrollPos = maxOffset
		}
		if local.scrollPos < 0 {
			local.scrollPos = 0
		}
		lineSlice = lineSlice[:len(lineSlice)-local.scrollPos]

		start := len(lineSlice) - serverRect.Height
		if start < 0 {
			start = 0
		}

		for _, line := range lineSlice[start:] {
			if serverRect.Height == 0 {
				break
			}
			term.RenderRawText(serverRect, line)
			serverRect.CutTop(1)
		}
	}

	// typescript error logs
	if tsErrorCount > 0 {
		titleRect := tsRect.CutTop(1)
		term.RenderStyledBlock(titleRect, term.JustStyledSpan(titleStyle, "  == Typescript Errors == "))

		filenameStyle := term.Style{
			Foreground: term.White + term.BrightOffset,
			Attr:       term.Bold | term.DefaultBackground,
		}

		for i, diag := range local.tsReport.Diagnostics {
			rect := tsRect.CutTop(1)

			var b term.StyledBlockBuilder
			b.PushSpan(filenameStyle, fmt.Sprintf("%s:%d", diag.Filename, diag.Line))
			term.RenderStyledBlock(rect, b.Done())

			var expanded = &local.tsReportState.expanded[i]
			if ClickInRect(rect) {
				*expanded = !*expanded
			}

			// file quote ....
			if *expanded {
				var buf strings.Builder
				vbeam.PrintTSDiagnosticQuote(&buf, diag)
				var str = buf.String()
				lines := strings.Count(str, "\n")
				rect := tsRect.CutTop(lines)
				term.RenderRawText(rect, str)
			}
		}
	}

	// status bar
	{
		var point = statusRect.Point
		RenderText(&point, term.DefaultStyle, formatDuration(time.Since(startTime)))
		point.X = 20
		RenderText(&point, term.DefaultStyle, fmt.Sprintf("scroll: %d", local.scrollPos))
		point.X = 34
		RenderText(&point, term.DefaultStyle, fmt.Sprintf("logs: %d lines", len(local.logs)))

		if local.Error != nil {
			point.X = 60

			errorMsg := fmt.Sprintf("%v", local.Error)
			RenderText(&point, errorStyle, errorMsg)
		}
	}
}

func initTermUI() {
	term.Init()
	term.EnterAltScreen()
	term.EnableMouse()
	term.HideCursor()
	generic.AddExitCleanup(func() {
		term.ShowCursor()
		term.DisableMouse()
		term.ExitAltScreen()
		term.Deinit()
	})
	return
}

type LocalServerArgs struct {
	Domain      string
	Port        int
	FEOpts      esbuilder.FEBuildOptions
	FEWatchDirs []string

	StartServer func()
}

func LaunchUI(args LocalServerArgs) {
	generic.SetupSigTermCleanup()
	defer generic.Cleanup()
	defer vbeam.NiceStackTraceOnPanic()

	local := &_LocalDev{
		LocalServerArgs: args,
	}
	log.SetOutput(&local.buf)

	initTermUI()

	go func() {
		var tsChannel = make(chan vbeam.TSReport, 1)
		var esChannel = make(chan esbuilder.ESReport, 1)
		// set report from channel!
		go func() {
			for report := range tsChannel {
				local.tsReport = report
				local.tsReportState = makeTSReportUI(report)
			}
		}()
		go func() {
			for report := range esChannel {
				local.esReport = report
				// log.Printf("Got ESBuild Report\n%#v", report)
				for _, msg := range report.Messages {
					log.Println(msg)
				}
				for _, err := range report.Errors {
					log.Println(err.Text)
				}
			}
		}()

		go esbuilder.FEWatch(local.FEOpts, local.FEWatchDirs, esChannel)
		go vbeam.TSWatch(local.FEWatchDirs, tsChannel)
		go args.StartServer()

		local.Started = true
	}()

	term.ClearScreen()

	const FPS = 60
	term.StartEventLoop(func(events []term.Event) {
		{
			for _, event := range events {
				switch event.Type {
				case term.KeyboardEvent:
					FrameInput.Key = event.Key
					switch event.Key {
					case term.Esc, term.CtrlC: // esc or ctrl-c
						generic.ExitWithCleanup(0)
					case 257, 'k': // up
						local.scrollPos += 1
					case 258, 'j': // down
						local.scrollPos -= 1
					}
				case term.MouseEvent:
					if event.MouseAction == term.MousePress {
						FrameInput.Click = event.MousePos
						FrameInput.MouseButton = event.MouseButton
					} else {
						FrameInput.MouseButton = term.MouseButtonNone
					}
					if event.MouseAction == term.WheelUp {
						local.scrollPos++
					}
					if event.MouseAction == term.WheelDown {
						local.scrollPos--
					}
				}
			}
		}
		// term.ClearScreen()
		local.renderFrame()

		// reset input state
		FrameInput.MouseButton = term.MouseButtonNone
		FrameInput.Key = 0
	}, FPS)
}
